# 后端 `bangumi` 服务代码审查报告

**审查员:** Linus Torvalds
**日期:** 2025年11月25日

---

## 1. 总体评价

我本来以为会看到一坨意大利面条式的代码，结果发现你们的后端架构居然还有点章法，尤其是在外部数据获取和缓存设计上，展现了不错的“品味”。

但是，**一个致命的、设计极其糟糕的 `subscriptions` (用户订阅) 模块，几乎摧毁了其他部分的所有优点。** 这个模块的性能问题是灾难性的，如果不修改，随着用户数据的增长，整个应用必然会变得卡顿无比。

### 【品味评分】

- **整体架构 (除订阅外):** 🟢 **好品味 (Good Taste)**
- **订阅模块 (`subscriptions`):** 🔴 **垃圾 (Garbage)**

---

## 2. 详细分析

### ✅ 做得好的地方 (The Good Parts)

1.  **清晰的架构分层**: `bangumi_service` 模块遵循了 `Command -> Service -> Infra` 的清晰分层，职责分明。
2.  **聪明的持久化缓存**: 使用独立的 `cache.sqlite` 作为持久化缓存，对于桌面应用来说是一个务实且高效的选择，避免了重复网络请求。
3.  **漂亮的数据隔离**: 将随时可丢弃的缓存 (`cache.sqlite`) 和核心用户数据 (`data.sqlite`) 存储在两个独立的数据库中，这是一个非常聪明的设计，降低了系统复杂性和维护风险。
4.  **良好的代码抽象**: `services/bangumi_service/api.rs` 中的 `fetch_api` 函数，将缓存检查和 API 请求的通用模式进行了良好封装，避免了代码重复。

### ❌ 致命的设计缺陷 (Fatal Design Flaws)

#### 问题一：自杀式的索引重建 (`refresh_index_all`)

这是整个后端最严重、最不可饶恕的问题。

- **现象**: 在 `subscriptions/store.rs` 中，`refresh_index_all` 函数会获取用户订阅的**所有**番剧 ID，然后为**每一个 ID** 都重新执行一次网络/缓存请求和数据库写入，以重建 `subjects_index` 搜索索引表。
- **病因**: 更离谱的是，这个性能极差的函数，在 `commands/subscriptions.rs` 的 `sub_query` 中被调用，导致**用户每一次执行搜索时**，都会触发一次完整的索引重建。
- **诊断**: 这是我见过最反模式、最浪费资源的设计。它让索引失去了意义，变成了拖垮整个应用的性能黑洞。

> **"你建好了一个索引来加速查询，但你却在每次查询前都把它推倒重来一遍。这不叫优化，这叫自残。"**

#### 问题二：教科书式的 N+1 查询

- **现象**: `commands/subscriptions.rs` 中的 `sub_list` 和 `sub_query` 函数，都犯了典型的 N+1 查询错误。
- **病因**: 它们从数据库只获取了番剧的 ID 列表，然后通过循环，为列表中的每一个 ID 都单独调用 `fetch_subject` 来获取详情。用户有 50 个订阅，就会触发 1+50=51 次查询。
- **诊断**: 即使有并发和缓存，这种设计本身就是懒惰和低效的。你们已经有了一个包含所有搜索信息的 `subjects_index` 表，却完全没有在列表展示时利用起来。

> **"你们建好了一个装满食材的 pantry (`subjects_index`)，但每次做饭时，却选择一次又一次地跑去农场 (`fetch_subject`) 单独拿每个食材。"**

#### 问题三：架构不一致与逻辑混乱

- **现象**: `subscriptions` 模块没有遵循其他部分 `Command -> Service` 的清晰分层。
- **病因**: `commands/subscriptions.rs` 直接调用了 `subscriptions` 模块，而这个模块（主要是`store.rs`）将业务逻辑、数据访问和索引管理混在了一起。
- **诊断**: 这破坏了项目本身建立的良好架构，是一种设计上的倒退，导致 `store.rs` 文件功能臃肿，职责混乱。

---

## 3. 遗留问题清单

现在系统的主体是健康的。上次报告中指出的所有致命问题都已修复。但一次全面的审查，意味着要带着更挑剔的眼光，去审视那些在修复重大 bug 时可能会被忽略的细节。以下是仍然需要解决的问题，它们是区分“一个能跑的程序”和“一个优秀的软件”之间的差别：

1.  **数据不一致风险 (`toggle` 函数)**
    - **问题**: 在 `store.rs` 的 `toggle` 函数中，后台索引任务的失败是静默的（例如，如果 `bangumi_service::fetch_subject` 失败）。这可能导致主表 (`subscriptions`) 成功更新，但索引表 (`subjects_index`) 未能更新，造成数据不一致。用户在订阅列表能看到，但在搜索时却搜不到。
    - **修复建议**:
        -   在后台任务中加入更健壮的错误处理和重试机制。
        -   考虑在 `subscriptions` 表中引入一个 `is_indexed` 标志位。`toggle` 成功后将其设为 `false`，后台任务成功更新索引后将其设为 `true`。Worker 进程可以定期扫描 `is_indexed = false` 的条目并尝试修复。

2.  **类型定义的“谎言” (`make_subject_from_index` 函数)**
    - **问题**: `query_full` 和 `list_full` 通过 `make_subject_from_index` 函数返回的 `SubjectResponse` 对象是不完整的（`summary`, `infobox` 等字段为空或 `None`）。这会给前端开发者带来困惑，因为他们可能期望一个完整的 `SubjectResponse`。
    - **修复建议**:
        -   创建一个新的、专门用于列表和搜索结果的类型（例如 `SubjectIndexEntry`），它只包含 `subjects_index` 表中实际存储的字段。
        -   让 `list_full` 和 `query_full` 返回这个新的、诚实且数据准确的类型。

3.  **不完整的 `clear` 操作**
    - **问题**: `store.rs` 中的 `clear()` 函数只清空了 `subscriptions` 表，而没有清空 `subjects_index` 表。这导致 `subjects_index` 中残留着大量已取消订阅的番剧索引数据，造成数据库空间浪费和数据不一致。
    - **修复建议**:
        -   在 `clear` 函数中，同时执行 `DELETE FROM subjects_index` 操作。

4.  **后台 Worker 的静默失败 (`worker.rs`)**
    - **问题**: `worker.rs` 在刷新单个条目时，如果 `bangumi_service::fetch_subject` 或 `get_status_cached` 失败，会通过 `.ok()` 静默忽略错误，不留下任何日志记录。
    - **修复建议**:
        -   在 `worker.rs` 的刷新逻辑中，如果发生错误，应使用 `warn!` 或 `error!` 宏将具体的错误信息打印到日志中，以便诊断和追踪问题。

## 最终评语

你们已经构建了一座坚固的房子。上次审查中指出的所有致命问题都已得到解决。现在的系统在性能、架构和稳定性上都有了质的飞跃。

现在这些遗留问题，是关于检查房子的“电路”和“管道”是否绝对安全可靠，以及内部装修是否精益求精。它们是关于代码的**健壮性、可维护性和专业性**。解决它们，将把你们的软件从“一个能跑的程序”提升到“一个优秀的软件”的高度。你们离 A+ 的评价只有一步之遥。

---
